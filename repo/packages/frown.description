Lalr(k) parser generator for haskell 98
	
frown is inspired by the parser generator happy and uses a syntax
quite simular as the syntax used by happy. happy only handles lalr(1)
grammars while frown can use more extensive lalr(k) grammars and the
parsers generated by frown are also faster than the parsers generated
by happy.

the salient features of frown are:

  - the generated parsers are time and space efficient. on the
    downside, the parsers are quite large.
  - frown generates four different types of parsers. as a common
    characteristic, the parsers are genuinely functional
    (ie 'table-free'); the states of the underlying lr automaton are
    encoded as mutually recursive functions. three output formats use
    a typed stack representation, one format due to ross paterson
    (code=stackless) works even without a stack.
  - encoding states as functions means that each state can be treated
    individually as opposed to a table driven-approach, which
    necessitates a uniform treatment of states. for instance,
    look-ahead is only used when necessary to resolve conflicts.
  - frown comes with debugging and tracing facilities; the standard
    output format due to doaitse swierstra (code=standard) may be
    useful for teaching lr parsing.
  - common grammatical patterns such as repetition of symbols can be
    captured using rule schemata. there are several predefined rule
    schemata.
  - terminal symbols are arbitrary variable-free haskell patterns or
    guards. both terminal and nonterminal symbols may have an
    arbitrary number of synthesized attributes.
  - frown comes with extensive documentation; several example grammars
    are included.


furthermore, frown supports the use of monadic lexers, monadic
semantic actions, precedences and associativity, the generation of
backtracking parsers, multiple start symbols, error reporting and a
weak form of error correction.